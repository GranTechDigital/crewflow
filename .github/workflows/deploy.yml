name: Deploy CrewFlow to Production
run-name: ${{ inputs.run_name || github.event.head_commit.message || format('Deploy {0} by {1}', github.ref_name, github.actor) }}

on:
  push:
    branches: [main]
    paths:
      - "src/**"
      - "prisma/**"
      - "Dockerfile"
      - "docker-compose.yml"
  workflow_dispatch:
    inputs:
      run_name:
        description: "Nome do run (opcional) ‚Äî deixe vazio para usar branch/autor"
        type: string
        required: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîß Build Docker image (cache disabled for safety)
        uses: docker/build-push-action@v5
        with:
          context: .
          tags: |
            crewflow-app:${{ github.sha }}
            crewflow-app:latest
          load: true
          no-cache: true

      - name: üîë Setup SSH
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå SSH_PRIVATE_KEY secret n√£o est√° configurado"; exit 1; fi
          if [ -z "${{ secrets.SERVER_HOST }}" ]; then
            echo "‚ùå SERVER_HOST secret n√£o est√° configurado"; exit 1; fi
          PORT="${{ secrets.SERVER_SSH_PORT }}"; [ -z "$PORT" ] && PORT=22
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          printf 'Host %s\n  Port %s\n  User root\n  StrictHostKeyChecking no\n' "${{ secrets.SERVER_HOST }}" "$PORT" >> ~/.ssh/config
          ssh-keyscan -p "$PORT" -T 10 -H "${{ secrets.SERVER_HOST }}" >> ~/.ssh/known_hosts || { echo "‚ùå ssh-keyscan falhou para host '${{ secrets.SERVER_HOST }}' porta $PORT"; exit 1; }

      - name: üíæ Backup banco de dados (produ√ß√£o) antes do deploy
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e
            mkdir -p /var/backups/projetogran/producao
            TS=$(date -u +%Y%m%d_%H%M%S)
            FILE="/var/backups/projetogran/producao/crewflow_production_${TS}.dump"
            echo "üîé Sanity-check container e DB antes do dump..."
            docker ps --format '{{.Names}}' | grep -q '^postgres-prod$' || { echo '‚ùå Container postgres-prod n√£o est√° em execu√ß√£o'; exit 1; }
            # Obter vari√°veis do DB com fallback seguro
            POSTGRES_PASSWORD_VALUE="${{ secrets.POSTGRES_PASSWORD }}"
            DB_NAME=$(docker exec postgres-prod bash -lc 'echo -n "${POSTGRES_DB:-projetogran}"')
            DB_USER=$(docker exec postgres-prod bash -lc 'echo -n "${POSTGRES_USER:-postgres}"')
            DB_PASS=$(docker exec postgres-prod bash -lc 'echo -n "${POSTGRES_PASSWORD:-}"')
            if [ -z "$DB_PASS" ]; then
              if [ -f /opt/projetogran/.env.production ]; then
                DB_PASS=$(grep -E '^POSTGRES_PASSWORD=' /opt/projetogran/.env.production | head -n1 | cut -d= -f2-)
              fi
            fi
            if [ -z "$DB_PASS" ]; then
              DB_PASS="$POSTGRES_PASSWORD_VALUE"
            fi
            if [ -z "$DB_PASS" ]; then
              echo "‚ö†Ô∏è POSTGRES_PASSWORD n√£o encontrado; usando fallback padr√£o"; DB_PASS="postgres"
            fi

            echo "üîé Validando conex√£o ao DB '${DB_NAME}'..."
            DB_USER=${DB_USER:-postgres}
            DB_NAME=${DB_NAME:-projetogran}
            docker exec postgres-prod env PGPASSWORD="$DB_PASS" psql -h localhost -U "$DB_USER" -d "$DB_NAME" -tAc "SELECT current_database();" | grep -q "^${DB_NAME}$" || { echo "‚ùå Conex√£o ao DB ${DB_NAME} falhou"; exit 1; }
            echo "üîé Realizando pg_dump (custom format) do banco '${DB_NAME}'..."
            docker exec postgres-prod env PGPASSWORD="$DB_PASS" pg_dump -h localhost -U "$DB_USER" -d "$DB_NAME" -Fc > "$FILE"
            ls -lh "$FILE" || true
            if [ ! -s "$FILE" ]; then
              echo "‚ùå Backup vazio ou n√£o encontrado: $FILE"; exit 1; fi
            echo "‚úÖ Backup criado: $FILE"
            ls -1t /var/backups/projetogran/producao/crewflow_production_*.dump | tail -n +31 | xargs -r rm -f
          EOF

      - name: üßπ Prepare server before image load (no prune)
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e
            echo "üìä Disk usage before image load:"
            df -h
            echo "üßÆ Docker system df (before):"
            docker system df || true
            echo "üßº Cleaning /tmp to free ephemeral space"
            rm -rf /tmp/* || true
            echo "‚ÑπÔ∏è Skipping Docker prune (enough disk space)"
            echo "üìä Disk usage after cleanup (no prune):"
            df -h
            echo "üßÆ Docker system df (after):"
            docker system df || true
          EOF

      - name: üöö Stream Docker image to server
        run: |
          docker save crewflow-app:${{ github.sha }} crewflow-app:latest | gzip -1 | ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} "gunzip | docker load"

      - name: üì§ Upload files to server
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} "mkdir -p /opt/projetogran"
          scp -o StrictHostKeyChecking=no docker-compose.yml root@${{ secrets.SERVER_HOST }}:/opt/projetogran/
          # Gerar/atualizar /opt/projetogran/.env.production a partir dos Secrets
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} "bash -lc 'set -e; ENV_FILE=/opt/projetogran/.env.production; touch \"$ENV_FILE\"; chmod 600 \"$ENV_FILE\"; 
            POSTGRES_USER_VALUE=postgres;
            POSTGRES_DB_VALUE=projetogran;
            POSTGRES_PASSWORD_VALUE=\"${{ secrets.POSTGRES_PASSWORD }}\";
            PGADMIN_EMAIL_VALUE=\"${{ secrets.PGADMIN_EMAIL }}\";
            PGADMIN_PASSWORD_VALUE=\"${{ secrets.PGADMIN_PASSWORD }}\";
            NEXTAUTH_URL_VALUE=\"http://${{ secrets.SERVER_HOST }}:3001\";
            JWT_SECRET_VALUE=\"${{ secrets.JWT_SECRET }}\";
            [ -z \"$POSTGRES_PASSWORD_VALUE\" ] && POSTGRES_PASSWORD_VALUE=\"postgres\";
            [ -z \"$PGADMIN_EMAIL_VALUE\" ] && PGADMIN_EMAIL_VALUE=\"admin@crewflow.com\";
            [ -z \"$PGADMIN_PASSWORD_VALUE\" ] && PGADMIN_PASSWORD_VALUE=\"admin123\";
            if [ -z \"$JWT_SECRET_VALUE\" ]; then if command -v openssl >/dev/null 2>&1; then JWT_SECRET_VALUE=$(openssl rand -hex 32); else JWT_SECRET_VALUE=$(date +%s%N | sha256sum | cut -c1-64); fi; fi;
            ensure_var() { key=\"$1\"; val=\"$2\"; if grep -q \"^${key}=\" \"$ENV_FILE\"; then sed -i \"s/^${key}=.*/${key}=${val}/\" \"$ENV_FILE\"; else echo \"${key}=${val}\" >> \"$ENV_FILE\"; fi; }; 
            ensure_var POSTGRES_USER \"$POSTGRES_USER_VALUE\";
            ensure_var POSTGRES_PASSWORD \"$POSTGRES_PASSWORD_VALUE\";
            ensure_var POSTGRES_DB \"$POSTGRES_DB_VALUE\";
            ensure_var PGADMIN_DEFAULT_EMAIL \"$PGADMIN_EMAIL_VALUE\";
            ensure_var PGADMIN_DEFAULT_PASSWORD \"$PGADMIN_PASSWORD_VALUE\";
            ensure_var NEXTAUTH_URL \"$NEXTAUTH_URL_VALUE\";
            ensure_var JWT_SECRET \"$JWT_SECRET_VALUE\";
            DB_USER=\"$POSTGRES_USER_VALUE\"; DB_PASS=\"$POSTGRES_PASSWORD_VALUE\"; DB_NAME=\"$POSTGRES_DB_VALUE\";
            DATABASE_URL_VALUE=\"postgresql://${DB_USER}:${DB_PASS}@postgres-prod:5432/${DB_NAME}?schema=public\";
            ensure_var DATABASE_URL \"$DATABASE_URL_VALUE\";'
          "

      - name: üîç Detect prisma changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            prisma:
              - 'prisma/**'

      - name: üöÄ Deploy on server
        run: |
          echo "üì¶ Preparando deploy com Docker Compose usando env-file"
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e
            echo "üìä Disk usage before deploy:"
            df -h
            cd /opt/projetogran

            # Garantir tags previs√≠veis da imagem (latest e SHA atual) para o compose
            SRC_TAG=$(docker image ls crewflow-app --format '{{.Tag}}' | grep -v '^<none>$' | head -n1)
            if [ -n "$SRC_TAG" ]; then
              docker tag crewflow-app:"$SRC_TAG" crewflow-app:latest || true
              docker tag crewflow-app:"$SRC_TAG" crewflow-app:${{ github.sha }} || true
            fi

            docker system df || true

            # Instalar Docker Compose v2 se necess√°rio
            if ! docker compose version >/dev/null 2>&1; then
              echo "Instalando Docker Compose v2..."
              DOCKER_CONFIG=~/.docker
              mkdir -p "$DOCKER_CONFIG/cli-plugins"
              curl -SL https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64 -o "$DOCKER_CONFIG/cli-plugins/docker-compose"
              chmod +x "$DOCKER_CONFIG/cli-plugins/docker-compose"
            fi

            # Garantir rede externa necess√°ria para o compose
            docker network inspect projetogran_crewflow-network >/dev/null 2>&1 || docker network create projetogran_crewflow-network

            # Subir servi√ßos via compose com env-file
            docker compose --env-file /opt/projetogran/.env.production -f /opt/projetogran/docker-compose.yml down || true
            docker compose --env-file /opt/projetogran/.env.production -f /opt/projetogran/docker-compose.yml pull || true
            docker compose --env-file /opt/projetogran/.env.production -f /opt/projetogran/docker-compose.yml up -d

            echo "üìä Disk usage after compose up:"
            df -h

            sleep 10
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
            docker logs --tail=200 crewflow-app-production 2>/dev/null || true
          EOF

      - name: üóÑÔ∏è Setup Database (run every deploy)
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            cd /opt/projetogran

            echo "‚è≥ Waiting for PostgreSQL to be ready..."
            sleep 10

            # Ensure migration_lock provider is Postgres inside the container
            docker exec crewflow-app-production sh -lc "if grep -q 'provider = \"sqlite\"' prisma/migrations/migration_lock.toml; then echo '‚ö†Ô∏è Fixing migration_lock provider from sqlite to postgresql'; printf '# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = \"postgresql\"\n' > prisma/migrations/migration_lock.toml; fi; echo 'üîé Current migration_lock:'; cat prisma/migrations/migration_lock.toml"

            echo "üîé Checking migration baseline in Postgres (_prisma_migrations)..."
            MIG_TABLE_EXISTS=$(docker exec postgres-prod bash -lc 'export PGPASSWORD="$POSTGRES_PASSWORD"; psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -tAc "SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema=''public'' AND table_name=''_prisma_migrations'');"')
            if [ "$MIG_TABLE_EXISTS" = "t" ]; then
              INIT_APPLIED=$(docker exec postgres-prod bash -lc 'export PGPASSWORD="$POSTGRES_PASSWORD"; psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -tAc "SELECT EXISTS (SELECT 1 FROM public._prisma_migrations WHERE migration_name = ''20251013111730_init'');"')
              if [ "$INIT_APPLIED" != "t" ]; then
                echo "‚ÑπÔ∏è Marking baseline migration '20251013111730_init' as applied (existing DB)"
                docker exec crewflow-app-production npx prisma migrate resolve --applied "20251013111730_init" || true
              else
                echo "‚úÖ Baseline migration already applied"
              fi
            else
              echo "‚ÑπÔ∏è Fresh database (no _prisma_migrations table). 'migrate deploy' will apply baseline."
            fi

            echo "üöÄ Applying Postgres migrations only..."
            docker exec crewflow-app-production npx prisma migrate deploy

            echo "üå± Seeding database (idempotent) ..."
            if docker exec crewflow-app-production npm run seed:complete 2>/dev/null; then
              echo "‚úÖ Database seeded successfully"
            else
              echo "‚ÑπÔ∏è Seed skipped (database already populated or error occurred)"
            fi
          EOF

      - name: "üîé Health check: app responds (login route)"
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e
            echo "üîé Checking /login endpoint..."
            if command -v curl >/dev/null 2>&1; then
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/login)
              echo "HTTP status: $STATUS"
              case "$STATUS" in
                200|302|307|308)
                  echo "‚úÖ App responding on /login"
                  ;;
                *)
                  echo "‚ùå Unexpected status on /login: $STATUS"
                  exit 1
                  ;;
              esac
            else
              STATUS=$(wget --server-response -q -O - http://localhost:3001/login 2>&1 | awk '/^  HTTP/{print $2}' | tail -n1)
              echo "HTTP status: $STATUS"
              if [ "$STATUS" = "200" ] || [ "$STATUS" = "302" ] || [ "$STATUS" = "307" ] || [ "$STATUS" = "308" ]; then
                echo "‚úÖ App responding on /login"
              else
                echo "‚ùå Unexpected status on /login: $STATUS"
                exit 1
              fi
            fi
          EOF

      - name: üéâ Deployment complete
        run: |
          echo "üöÄ Deployment completed successfully!"
          echo "üåê Application available at: http://${{ secrets.SERVER_HOST }}:3001"
          echo "üóÑÔ∏è PostgreSQL running on port 5434 with persistent volume"
          echo "üîß pgAdmin4 available at: http://${{ secrets.SERVER_HOST }}:5050"
          echo "üìß pgAdmin Login: admin@crewflow.com (senha definida no ambiente)"
          echo "üîê App Login: usu√°rio administrador configurado via vari√°veis de ambiente"
