name: Deploy to Production Server
run-name: ${{ inputs.run_name || github.event.head_commit.message || format('Deploy {0} by {1}', github.ref_name, github.actor) }}

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'prisma/**'
      - 'Dockerfile'
      - 'docker-compose.yml'
  workflow_dispatch:
    inputs:
      run_name:
        description: 'Nome do run (opcional) â€” deixe vazio para usar branch/autor'
        type: string
        required: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ”§ Build Docker image (cache disabled for safety)
        uses: docker/build-push-action@v5
        with:
          context: .
          tags: |
            crewflow-app:${{ github.sha }}
            crewflow-app:latest
          load: true
          no-cache: true

      - name: ğŸ”‘ Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸ§¹ Prepare server before image load (no prune)
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e
            echo "ğŸ“Š Disk usage before image load:"
            df -h
            echo "ğŸ§® Docker system df (before):"
            docker system df || true
            echo "ğŸ§¼ Cleaning /tmp to free ephemeral space"
            rm -rf /tmp/* || true
            echo "â„¹ï¸ Skipping Docker prune (enough disk space)"
            echo "ğŸ“Š Disk usage after cleanup (no prune):"
            df -h
            echo "ğŸ§® Docker system df (after):"
            docker system df || true
          EOF

      - name: ğŸšš Stream Docker image to server
        run: |
          docker save crewflow-app:${{ github.sha }} crewflow-app:latest | gzip -1 | ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} "gunzip | docker load"

      - name: ğŸ“¤ Upload files to server
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} "mkdir -p /opt/projetogran"
          scp -o StrictHostKeyChecking=no docker-compose.yml root@${{ secrets.SERVER_HOST }}:/opt/projetogran/

      - name: ğŸ” Detect prisma changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            prisma:
              - 'prisma/**'

      - name: ğŸš€ Deploy on server
        run: |
          # Use quoted heredoc to prevent local shell from expanding remote variables like $APP_TAG
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e
            echo "ğŸ“Š Disk usage before deploy:" 
            df -h
            cd /opt/projetogran

            echo "ğŸ” Image details after load:"
            docker images | grep crewflow-app || true

            # Ensure the loaded image has predictable tags (latest and current SHA)
            SRC_TAG=$(docker image ls crewflow-app --format '{{.Tag}}' | grep -v '^<none>$' | head -n1)
            if [ -n "$SRC_TAG" ]; then
              docker tag crewflow-app:"$SRC_TAG" crewflow-app:latest || true
              docker tag crewflow-app:"$SRC_TAG" crewflow-app:${{ github.sha }} || true
            fi

            docker stop $(docker ps -aq --filter "name=crewflow-app-production") 2>/dev/null || true
            docker rm $(docker ps -aq --filter "name=crewflow-app-production") 2>/dev/null || true

            docker network create projetogran_crewflow-network 2>/dev/null || true

            APP_TAG_GH=${{ github.sha }}
            # Sanitize possible CR/LF or spaces from GH SHA
            APP_TAG_GH=$(echo "$APP_TAG_GH" | tr -d '\r' | tr -d '[:space:]')
            # Default to latest to avoid empty tag
            APP_TAG=latest
            if [ -n "$APP_TAG_GH" ] && docker image inspect "crewflow-app:${APP_TAG_GH}" > /dev/null 2>&1; then
              APP_TAG="$APP_TAG_GH"
            elif docker image inspect "crewflow-app:latest" > /dev/null 2>&1; then
              APP_TAG=latest
            else
              # Fallback: first available tag for crewflow-app (excluding <none>)
              APP_TAG_FALLBACK=$(docker image ls crewflow-app --format '{{.Tag}}' | grep -v '^<none>$' | head -n1)
              APP_TAG_FALLBACK=$(echo "$APP_TAG_FALLBACK" | tr -d '\r' | tr -d '[:space:]')
              if [ -n "$APP_TAG_FALLBACK" ]; then
                APP_TAG="$APP_TAG_FALLBACK"
              else
                echo "âŒ No valid tag found for crewflow-app. Available images:"
                docker image ls crewflow-app || docker images | grep '^crewflow-app' || true
                exit 1
              fi
            fi
            echo "ğŸš€ Using image tag: $APP_TAG"
            docker run -d \
              --name crewflow-app-production \
              --network projetogran_crewflow-network \
              -e DATABASE_URL="postgresql://crewflow_user:crewflow_production_2024@postgres-prod:5432/crewflow_production?schema=public" \
              -e JWT_SECRET=crewflow-jwt-secret-key-2024 \
              -e NEXTAUTH_URL=http://${{ secrets.SERVER_HOST }}:3001 \
              -e NODE_ENV=production \
              -p 3001:3001 \
              --restart unless-stopped \
              crewflow-app:${APP_TAG}

            echo "ğŸ“Š Disk usage after image load:" 
            df -h

            sleep 5

            if docker ps | grep -q "crewflow-app-production"; then
              echo "âœ… App container started successfully"
              docker ps | grep "crewflow-app-production"
              echo "ğŸ” Image details:"
              docker images | grep crewflow-app
              docker inspect crewflow-app-production --format 'container image: {{.Image}}'
            else
              echo "âŒ App container failed to start"
              docker ps
              docker logs crewflow-app-production 2>/dev/null || true
              exit 1
            fi
          EOF

      - name: ğŸ—„ï¸ Setup Database (only on prisma changes)
        if: steps.changes.outputs.prisma == 'true'
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            cd /opt/projetogran

            echo "â³ Waiting for PostgreSQL to be ready..."
            sleep 10

            # Hotfix: ensure migration_lock provider matches Postgres inside container
            docker exec crewflow-app-production sh -lc "if grep -q 'provider = \"sqlite\"' prisma/migrations/migration_lock.toml; then echo 'âš ï¸ Fixing migration_lock provider from sqlite to postgresql'; printf '# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = \"postgresql\"\n' > prisma/migrations/migration_lock.toml; fi; echo 'ğŸ” Current migration_lock:'; cat prisma/migrations/migration_lock.toml"

            echo "ğŸ©¹ Marking legacy SQLite migrations as applied (skip running their SQL)..."
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250902123443_add_data_vencimento" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250903112552_add_uptime_upload_model" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250903133325_create_uptime_sheet" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250903151921_remove_uptime_sheet" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250903162029_create_uptime_sheet_columns" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250904121815_ajuste_relacao_uptimesheet" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250917113538_create_downtime_sheet" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250918184957_add_periodo_columns" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250919132509_add_data_relatorio_uptime_upload" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250919150416_create_periodo_tables" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250923112622_create_status_mapping" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250924144015_add_regime_trabalho_and_ids_mapping" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250925124643_add_planilha_columns" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250925130000_create_funcoes_table" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250926171502_add_nome_centro_custo" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250928145113_add_centro_custo_to_periodo_sheet" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250930135019_create_treinamentos_table_force" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20250930142329_update_treinamentos_fields" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20251001160518_create_matriz_treinamento" || true
            docker exec crewflow-app-production npx prisma migrate resolve --applied "20251001192820_make_treinamento_optional" || true

            echo "ğŸš€ Applying Postgres migrations..."
            docker exec crewflow-app-production npx prisma migrate deploy

            echo "ğŸŒ± Seeding database (idempotent) ..."
            if docker exec crewflow-app-production npm run seed:complete 2>/dev/null; then
              echo "âœ… Database seeded successfully"
            else
              echo "â„¹ï¸ Seed skipped (database already populated or error occurred)"
            fi
          EOF

      - name: "ğŸ” Health check: app responds (login route)"
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e
            echo "ğŸ” Checking /login endpoint..."
            if command -v curl >/dev/null 2>&1; then
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/login)
              echo "HTTP status: $STATUS"
              case "$STATUS" in
                200|302|307|308)
                  echo "âœ… App responding on /login"
                  ;;
                *)
                  echo "âŒ Unexpected status on /login: $STATUS"
                  exit 1
                  ;;
              esac
            else
              STATUS=$(wget --server-response -q -O - http://localhost:3001/login 2>&1 | awk '/^  HTTP/{print $2}' | tail -n1)
              echo "HTTP status: $STATUS"
              if [ "$STATUS" = "200" ] || [ "$STATUS" = "302" ] || [ "$STATUS" = "307" ] || [ "$STATUS" = "308" ]; then
                echo "âœ… App responding on /login"
              else
                echo "âŒ Unexpected status on /login: $STATUS"
                exit 1
              fi
            fi
          EOF

      - name: ğŸ‰ Deployment complete
        run: |
          echo "ğŸš€ Deployment completed successfully!"
          echo "ğŸŒ Application available at: http://${{ secrets.SERVER_HOST }}:3001"
          echo "ğŸ—„ï¸ PostgreSQL running on port 5434 with persistent volume"
          echo "ğŸ”§ pgAdmin4 available at: http://${{ secrets.SERVER_HOST }}:5050"
          echo "ğŸ“§ pgAdmin Login: admin@crewflow.com / admin123"
          echo "ğŸ” App Login: ADMIN001 / admin123"
