name: Deploy CrewFlow to Production

concurrency:
  group: production-deploy
  cancel-in-progress: true

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      run_name:
        description: "Nome do run (opcional) ‚Äî deixe vazio para usar branch/autor"
        type: string
        required: false
      skip_backup:
        description: "Pular backup do banco (apenas workflow manual)"
        type: boolean
        required: false
        default: false
      reset_pgadmin:
        description: "Resetar credenciais do pgAdmin (apenas workflow manual)"
        type: boolean
        required: false
        default: false
      run_backfill:
        description: "Executar backfills (apenas workflow manual)"
        type: boolean
        required: false
        default: false
      apply_db_changes:
        description: "Aplicar mudan√ßas de banco (migrations/seed/backfills). Padr√£o: n√£o aplicar."
        type: boolean
        required: false
        default: false

jobs:
  deploy:
    environment: production
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîß Build Docker image (with Buildx cache)
        uses: docker/build-push-action@v5
        with:
          context: .
          tags: |
            crewflow-app:${{ github.sha }}
            crewflow-app:latest
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: üîë Setup SSH
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.PROD_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå SSH_PRIVATE_KEY secret n√£o est√° configurado"; exit 1; fi
          if [ -z "${{ secrets.PROD_SERVER_HOST }}" ]; then
            echo "‚ùå SERVER_HOST secret n√£o est√° configurado"; exit 1; fi
          PORT="${{ secrets.PROD_SERVER_SSH_PORT }}"; [ -z "$PORT" ] && PORT=22
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.PROD_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          printf 'Host %s\n  Port %s\n  User root\n  StrictHostKeyChecking no\n' "${{ secrets.PROD_SERVER_HOST }}" "$PORT" >> ~/.ssh/config
          # ssh-keyscan pode falhar por instabilidade de rede/firewall; tentar com retries e n√£o bloquear o deploy
          set +e
          ATTEMPTS=10; SLEEP=3; ADDED=0
          for i in $(seq 1 $ATTEMPTS); do
            ssh-keyscan -p "$PORT" -T 5 -H "${{ secrets.PROD_SERVER_HOST }}" >> ~/.ssh/known_hosts && { ADDED=1; break; }
            echo "‚ö†Ô∏è ssh-keyscan tentativa #$i falhou para host '${{ secrets.PROD_SERVER_HOST }}' porta $PORT"; sleep $SLEEP
          done
          set -e
          if [ "$ADDED" -ne 1 ]; then
            echo "‚ö†Ô∏è ssh-keyscan falhou; prosseguindo com StrictHostKeyChecking=no (config j√° aplicada)"
          fi

      - name: üíæ Backup banco de dados (produ√ß√£o) antes do deploy
        if: ${{ github.event_name != 'workflow_dispatch' || inputs.skip_backup != 'true' }}
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} << 'EOF'
            set -e
            mkdir -p /var/backups/projetogran/producao
            TS=$(date -u +%Y%m%d_%H%M%S)
            FILE="/var/backups/projetogran/producao/crewflow_production_${TS}.dump"
            echo "üîé Sanity-check container e DB antes do dump..."
            docker ps --format '{{.Names}}' | grep -q '^postgres-prod$' || { echo '‚ùå Container postgres-prod n√£o est√° em execu√ß√£o'; exit 1; }
            # Obter vari√°veis do DB com fallback seguro
            POSTGRES_PASSWORD_VALUE="${{ secrets.POSTGRES_PASSWORD }}"
            DB_NAME=$(docker exec postgres-prod bash -lc 'echo -n "${POSTGRES_DB:-projetogran}"')
            DB_USER=$(docker exec postgres-prod bash -lc 'echo -n "${POSTGRES_USER:-postgres}"')
            DB_PASS=$(docker exec postgres-prod bash -lc 'echo -n "${POSTGRES_PASSWORD:-}"')
            if [ -z "$DB_PASS" ]; then
              if [ -f /opt/projetogran/.env.production ]; then
                DB_PASS=$(grep -E '^POSTGRES_PASSWORD=' /opt/projetogran/.env.production | head -n1 | cut -d= -f2-)
              fi
            fi
            if [ -z "$DB_PASS" ]; then
              DB_PASS="$POSTGRES_PASSWORD_VALUE"
            fi
            if [ -z "$DB_PASS" ]; then
              echo "‚ö†Ô∏è POSTGRES_PASSWORD n√£o encontrado; usando fallback padr√£o"; DB_PASS="postgres"
            fi

            echo "üîé Validando conex√£o ao DB '${DB_NAME}'..."
            DB_USER=${DB_USER:-postgres}
            DB_NAME=${DB_NAME:-projetogran}
            docker exec postgres-prod env PGPASSWORD="$DB_PASS" psql -h localhost -U "$DB_USER" -d "$DB_NAME" -tAc "SELECT current_database();" | grep -q "^${DB_NAME}$" || { echo "‚ùå Conex√£o ao DB ${DB_NAME} falhou"; exit 1; }
            echo "üîé Realizando pg_dump (custom format, compress n√≠vel 1) do banco '${DB_NAME}'..."
            docker exec postgres-prod env PGPASSWORD="$DB_PASS" pg_dump -h localhost -U "$DB_USER" -d "$DB_NAME" -Fc -Z 1 > "$FILE"
            ls -lh "$FILE" || true
            if [ ! -s "$FILE" ]; then
              echo "‚ùå Backup vazio ou n√£o encontrado: $FILE"; exit 1; fi
            echo "‚úÖ Backup criado: $FILE"
            ls -1t /var/backups/projetogran/producao/crewflow_production_*.dump | tail -n +31 | xargs -r rm -f
          EOF

      - name: üßπ Prepare server before image load (safe prune)
        if: ${{ false }}
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} << 'EOF'
            set -e
            echo "üìä Disk usage before image load:"
            df -h
            echo "üßÆ Docker system df (before):"
            docker system df || true
            echo "üßº Pruning unused Docker images and caches (no volumes)"
            docker image prune -af || true
            docker builder prune -af || true
            docker system prune -af || true
            echo "üßº Cleaning /tmp to free ephemeral space"
            rm -rf /tmp/* || true
            echo "üßº Reducing journald logs size"
            journalctl --vacuum-size=200M || true
            echo "üìä Disk usage after cleanup (no prune):"
            df -h
            echo "üßÆ Docker system df (after):"
            docker system df || true
          EOF

      - name: üöö Upload Docker image to server (resilient)
        run: |
          set -euo pipefail
          FILE="/tmp/crewflow_${{ github.sha }}.tar.gz"
          echo "üì¶ Gerando arquivo de imagem compactado localmente: $FILE"
          docker save crewflow-app:${{ github.sha }} crewflow-app:latest | gzip -1 > "$FILE"
          ls -lh "$FILE"
          echo "üöö Transferindo imagem para o servidor via SCP com keepalive"
          scp -o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o ServerAliveCountMax=10 "$FILE" root@${{ secrets.PROD_SERVER_HOST }}:/tmp/
          echo "üì• Carregando imagem no Docker do servidor e removendo arquivo tempor√°rio"
          ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o ServerAliveCountMax=10 root@${{ secrets.PROD_SERVER_HOST }} "gunzip -c /tmp/crewflow_${{ github.sha }}.tar.gz | docker load && rm -f /tmp/crewflow_${{ github.sha }}.tar.gz"

      - name: üì§ Upload files and env to server
        run: |
          set -euo pipefail
          # Montar .env.production localmente para evitar problemas de quoting no SSH
          WORKDIR=/tmp/projetogran_deploy
          mkdir -p "$WORKDIR"
          ENV_FILE="$WORKDIR/.env.production"

          POSTGRES_USER_VALUE=postgres
          POSTGRES_DB_VALUE=projetogran
          POSTGRES_PASSWORD_VALUE="${{ secrets.PROD_POSTGRES_PASSWORD }}"
          PGADMIN_EMAIL_VALUE="${{ secrets.PROD_PGADMIN_EMAIL }}"
          PGADMIN_PASSWORD_VALUE="${{ secrets.PROD_PGADMIN_PASSWORD }}"
          PGADMIN_SETUP_EMAIL_VALUE="$PGADMIN_EMAIL_VALUE"
          PGADMIN_SETUP_PASSWORD_VALUE="$PGADMIN_PASSWORD_VALUE"
          NEXTAUTH_URL_VALUE="http://${{ secrets.PROD_SERVER_HOST }}:3002"
          JWT_SECRET_VALUE="${{ secrets.PROD_JWT_SECRET }}"
          ADMIN_USER_VALUE="${{ secrets.PROD_ADMIN_USER }}"
          ADMIN_EMAIL_VALUE="${{ secrets.PROD_ADMIN_EMAIL }}"
          ADMIN_PASSWORD_VALUE="${{ secrets.PROD_ADMIN_PASSWORD }}"
          ADMIN_FORCE_PASSWORD_VALUE="${{ secrets.PROD_ADMIN_FORCE_PASSWORD }}"

          [ -z "$POSTGRES_PASSWORD_VALUE" ] && POSTGRES_PASSWORD_VALUE="postgres"
          [ -z "$PGADMIN_EMAIL_VALUE" ] && PGADMIN_EMAIL_VALUE="admin@crewflow.com"
          [ -z "$PGADMIN_PASSWORD_VALUE" ] && PGADMIN_PASSWORD_VALUE="admin123"
          if [ -z "$JWT_SECRET_VALUE" ]; then
            if command -v openssl >/dev/null 2>&1; then
              JWT_SECRET_VALUE=$(openssl rand -hex 32)
            else
              JWT_SECRET_VALUE=$(date +%s%N | sha256sum | cut -c1-64)
            fi
          fi

          # Defaults para credenciais admin
          [ -z "$ADMIN_USER_VALUE" ] && ADMIN_USER_VALUE="ADMIN001"
          [ -z "$ADMIN_EMAIL_VALUE" ] && ADMIN_EMAIL_VALUE="admin@gransystem.com"
          [ -z "$ADMIN_PASSWORD_VALUE" ] && ADMIN_PASSWORD_VALUE="admin123"
          [ -z "$ADMIN_FORCE_PASSWORD_VALUE" ] && ADMIN_FORCE_PASSWORD_VALUE="false"

          DB_USER="$POSTGRES_USER_VALUE"; DB_PASS="$POSTGRES_PASSWORD_VALUE"; DB_NAME="$POSTGRES_DB_VALUE"
          DATABASE_URL_VALUE="postgresql://${DB_USER}:${DB_PASS}@postgres-prod:5432/${DB_NAME}?schema=public"

          : > "$ENV_FILE"
          printf 'POSTGRES_USER=%s\n' "$POSTGRES_USER_VALUE" >> "$ENV_FILE"
          printf 'POSTGRES_PASSWORD=%s\n' "$POSTGRES_PASSWORD_VALUE" >> "$ENV_FILE"
          printf 'POSTGRES_DB=%s\n' "$POSTGRES_DB_VALUE" >> "$ENV_FILE"
          printf 'PGADMIN_DEFAULT_EMAIL=%s\n' "$PGADMIN_EMAIL_VALUE" >> "$ENV_FILE"
          printf 'PGADMIN_DEFAULT_PASSWORD=%s\n' "$PGADMIN_PASSWORD_VALUE" >> "$ENV_FILE"
          printf 'PGADMIN_SETUP_EMAIL=%s\n' "$PGADMIN_SETUP_EMAIL_VALUE" >> "$ENV_FILE"
          printf 'PGADMIN_SETUP_PASSWORD=%s\n' "$PGADMIN_SETUP_PASSWORD_VALUE" >> "$ENV_FILE"
          printf 'PGADMIN_CONFIG_SERVER_MODE=%s\n' "True" >> "$ENV_FILE"
          printf 'PGADMIN_CONFIG_PATH_PREFIX=%s\n' "/pgadmin" >> "$ENV_FILE"
          printf 'NEXTAUTH_URL=%s\n' "$NEXTAUTH_URL_VALUE" >> "$ENV_FILE"
          printf 'JWT_SECRET=%s\n' "$JWT_SECRET_VALUE" >> "$ENV_FILE"
          printf 'DATABASE_URL=%s\n' "$DATABASE_URL_VALUE" >> "$ENV_FILE"
          printf 'ADMIN_USER=%s\n' "$ADMIN_USER_VALUE" >> "$ENV_FILE"
          printf 'ADMIN_EMAIL=%s\n' "$ADMIN_EMAIL_VALUE" >> "$ENV_FILE"
          printf 'ADMIN_PASSWORD=%s\n' "$ADMIN_PASSWORD_VALUE" >> "$ENV_FILE"
          printf 'ADMIN_FORCE_PASSWORD=%s\n' "$ADMIN_FORCE_PASSWORD_VALUE" >> "$ENV_FILE"

          ls -l "$ENV_FILE"
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} "mkdir -p /opt/projetogran"
          scp -o StrictHostKeyChecking=no docker-compose.yml root@${{ secrets.PROD_SERVER_HOST }}:/opt/projetogran/
          scp -o StrictHostKeyChecking=no nginx.conf root@${{ secrets.PROD_SERVER_HOST }}:/opt/projetogran/nginx.conf
          scp -o StrictHostKeyChecking=no "$ENV_FILE" root@${{ secrets.PROD_SERVER_HOST }}:/opt/projetogran/.env.production
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} "chmod 600 /opt/projetogran/.env.production"

      - name: üîç Detect changes (prisma/compose/scripts)
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            prisma:
              - 'prisma/**'
            compose:
              - 'docker-compose.yml'
              - 'Dockerfile'
              - 'nginx.conf'
            scripts:
              - 'scripts/**'

      - name: üöÄ Deploy on server
        run: |
          echo "üì¶ Preparando deploy com Docker Compose usando env-file"
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} << 'EOF'
            set -e
            echo "üìä Disk usage before deploy:"
            df -h
            cd /opt/projetogran

            # Garantir tags previs√≠veis da imagem (latest e SHA atual) para o compose
            SRC_TAG=$(docker image ls crewflow-app --format '{{.Tag}}' | grep -v '^<none>$' | head -n1)
            if [ -n "$SRC_TAG" ]; then
              docker tag crewflow-app:"$SRC_TAG" crewflow-app:latest || true
              docker tag crewflow-app:"$SRC_TAG" crewflow-app:${{ github.sha }} || true
            fi

            docker system df || true

            # Instalar Docker Compose v2 se necess√°rio
            if ! docker compose version >/dev/null 2>&1; then
              echo "Instalando Docker Compose v2..."
              DOCKER_CONFIG=~/.docker
              mkdir -p "$DOCKER_CONFIG/cli-plugins"
              curl -SL https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64 -o "$DOCKER_CONFIG/cli-plugins/docker-compose"
              chmod +x "$DOCKER_CONFIG/cli-plugins/docker-compose"
            fi

            # Garantir rede externa necess√°ria para o compose
            docker network inspect projetogran_crewflow-network >/dev/null 2>&1 || docker network create projetogran_crewflow-network

            # Subir servi√ßos via compose com env-file (atualiza apenas o que mudou)
          docker compose --env-file /opt/projetogran/.env.production -f /opt/projetogran/docker-compose.yml up -d

          echo "üìä Disk usage after compose up:"
          df -h

          sleep 10
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
          docker logs --tail=200 crewflow-app-production 2>/dev/null || true
          echo "üîé Verificando HTTP da aplica√ß√£o nas portas 3001, 3002 e via 80 (Nginx)"
          check_url() { URL="$1"; LABEL="$2"; CODE=""; if command -v curl >/dev/null 2>&1; then CODE=$(curl -sS -o /dev/null -w "%{http_code}" --max-time 5 "$URL" || true); else CODE=$(wget --server-response -q -O - "$URL" 2>&1 | awk '/^  HTTP/{print $2}' | tail -n1); fi; echo "$LABEL => HTTP: $CODE"; }
          check_url "http://localhost:3001/login" "local:3001/login"
          check_url "http://localhost:3002/login" "local:3002/login"
          check_url "http://localhost/login" "local:80/login"
          EOF

      - name: üîê Reset pgAdmin (restart non-interactive)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.reset_pgadmin == 'true' }}
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} << 'EOF'
            set -e
            echo "üîé Reiniciando pgadmin-production com vari√°veis de setup (n√£o-interativo)"
            cd /opt/projetogran
            # Recriar apenas o servi√ßo do pgAdmin, preservando volume e respeitando env (.env.production)
            docker compose --env-file /opt/projetogran/.env.production -f /opt/projetogran/docker-compose.yml up -d pgadmin-production
            echo "‚è≥ Aguardando pgAdmin iniciar"
            ATTEMPTS=20; SLEEP=3; CODE=""
            for i in $(seq 1 $ATTEMPTS); do
              if command -v curl >/dev/null 2>&1; then
                CODE=$(curl -sS -o /dev/null -w "%{http_code}" --max-time 3 http://localhost:5050/ || true)
              else
                CODE=$(wget --server-response -q -O - http://localhost:5050/ 2>&1 | awk '/^  HTTP/{print $2}' | tail -n1)
              fi
              echo "Tentativa #$i ‚Äî HTTP: $CODE"
              if [ "$CODE" = "200" ] || [ "$CODE" = "302" ] || [ "$CODE" = "307" ] || [ "$CODE" = "308" ]; then
                echo "‚úÖ pgAdmin responde"
                break
              fi
              sleep $SLEEP
            done
            docker logs --tail=120 pgadmin-production || true
          EOF

      - name: üóÑÔ∏è Setup Database (somente quando solicitado manualmente)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.apply_db_changes == 'true' && steps.changes.outputs.prisma == 'true' }}
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} << 'EOF'
            cd /opt/projetogran

            echo "‚è≥ Waiting for PostgreSQL to be ready..."
            sleep 10

            # Ensure migration_lock provider is Postgres inside the container
            docker exec crewflow-app-production sh -lc "if grep -q 'provider = \"sqlite\"' prisma/migrations/migration_lock.toml; then echo '‚ö†Ô∏è Fixing migration_lock provider from sqlite to postgresql'; printf '# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = \"postgresql\"\n' > prisma/migrations/migration_lock.toml; fi; echo 'üîé Current migration_lock:'; cat prisma/migrations/migration_lock.toml"

            echo "üîé Checking migration baseline in Postgres (_prisma_migrations)..."
            MIG_TABLE_EXISTS=$(docker exec postgres-prod bash -lc 'export PGPASSWORD="$POSTGRES_PASSWORD"; psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -tAc "SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema=''public'' AND table_name=''_prisma_migrations'');"')
            if [ "$MIG_TABLE_EXISTS" = "t" ]; then
              INIT_APPLIED=$(docker exec postgres-prod bash -lc 'export PGPASSWORD="$POSTGRES_PASSWORD"; psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -tAc "SELECT EXISTS (SELECT 1 FROM public._prisma_migrations WHERE migration_name = ''20251013111730_init'');"')
              if [ "$INIT_APPLIED" != "t" ]; then
                echo "‚ÑπÔ∏è Marking baseline migration '20251013111730_init' as applied (existing DB)"
                docker exec crewflow-app-production npx prisma migrate resolve --applied "20251013111730_init" || true
              else
                echo "‚úÖ Baseline migration already applied"
              fi
            else
              echo "‚ÑπÔ∏è Fresh database (no _prisma_migrations table). 'migrate deploy' will apply baseline."
            fi

            echo "üöÄ Applying Postgres migrations..."
            docker exec crewflow-app-production npx prisma migrate deploy || true
            echo "‚ÑπÔ∏è db push desabilitado por padr√£o (evitar drift for√ßado)"
            echo "‚ÑπÔ∏è seed desabilitado por padr√£o (evitar altera√ß√£o n√£o intencional)"
            echo "‚ÑπÔ∏è ensureAdmin desabilitado por padr√£o"
          EOF

      - name: üîÅ Run backfill scripts (somente quando solicitado manualmente)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.apply_db_changes == 'true' && inputs.run_backfill == 'true' }}
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} << 'EOF'
            set -e
            echo "üîÅ Running backfill scripts (conditional)..."
            docker exec crewflow-app-production node scripts/backfillEventosTarefa.js || true
            docker exec crewflow-app-production node scripts/backfillCapacitacoes.js || true
            docker exec crewflow-app-production node scripts/backfill-historico-usuarios.js || true
            echo "üîÅ Backfilling equipeId em eventos de tarefa (setores) ..."
            docker exec crewflow-app-production node scripts/backfill-tarefa-equipe.cjs --apply --batch=500 || true
            echo "üîÅ Ajustando dataEvento dos eventos CONCLUIDO/CONCLUIDA para dataConclusao da tarefa ..."
            docker exec crewflow-app-production node scripts/fix-eventos-data-conclusao.cjs --apply --batch=500 || true
          EOF

      - name: üßπ Cleanup old images (keep latest and current SHA)
        if: ${{ steps.changes.outputs.compose == 'true' }}
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} << 'EOF'
            set -e
            echo "üßπ Removing dangling images"
            docker image prune -af || true
            echo "üßπ Removing old crewflow-app tags (keeping latest and current SHA)"
            KEEP_TAGS="latest ${{ github.sha }}"
            IMAGES=$(docker images | awk '$1=="crewflow-app" {print $1 ":" $2}' | grep -v ':<none>$')
            for IMG in $IMAGES; do
              KEEP=false
              for T in $KEEP_TAGS; do
                if [ "$IMG" = "crewflow-app:$T" ]; then KEEP=true; break; fi
              done
              if [ "$KEEP" = "false" ]; then
                if ! docker ps -a --format '{{.Image}}' | grep -qx "$IMG"; then
                  echo "üóëÔ∏è Removing image: $IMG"
                  docker rmi "$IMG" || true
                else
                  echo "‚ÑπÔ∏è Skipping in-use image: $IMG"
                fi
              else
                echo "‚ÑπÔ∏è Keeping image: $IMG"
              fi
            done
            echo "üßÆ Docker system df (post-cleanup):"
            docker system df || true
          EOF

      - name: "üîé Health check: app responds (login route)"
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} << 'EOF'
            set -e
            echo "üîé Checking /login endpoint..."
            if command -v curl >/dev/null 2>&1; then
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/login)
              echo "HTTP status: $STATUS"
              case "$STATUS" in
                200|302|307|308)
                  echo "‚úÖ App responding on /login"
                  ;;
                *)
                  echo "‚ùå Unexpected status on /login: $STATUS"
                  exit 1
                  ;;
              esac
            else
              STATUS=$(wget --server-response -q -O - http://localhost:3001/login 2>&1 | awk '/^  HTTP/{print $2}' | tail -n1)
              echo "HTTP status: $STATUS"
              if [ "$STATUS" = "200" ] || [ "$STATUS" = "302" ] || [ "$STATUS" = "307" ] || [ "$STATUS" = "308" ]; then
                echo "‚úÖ App responding on /login"
              else
                echo "‚ùå Unexpected status on /login: $STATUS"
                exit 1
              fi
            fi
          EOF

      - name: "‚úÖ Verify Admin API Login (non-blocking)"
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} << 'EOF'
            set -e
            USER=ADMIN001
            PASS=admin123
            echo "üîé Testing login via API with matricula=$USER"
            RESP=$(curl -s -w '\n%{http_code}' -H 'Content-Type: application/json' -d "{\"matricula\":\"$USER\",\"senha\":\"$PASS\"}" http://localhost:3001/api/auth/login || true)
            BODY=$(echo "$RESP" | head -n1)
            CODE=$(echo "$RESP" | tail -n1)
            echo "HTTP: $CODE"
            echo "Body: $BODY"
            if [ "$CODE" = "200" ]; then
              echo "‚úÖ Admin login OK"
            else
              echo "‚ÑπÔ∏è Admin login n√£o retornou 200 (pode ter senha alterada). Prosseguindo."
            fi
          EOF

      - name: üîß pgAdmin health check and firewall
        if: ${{ steps.changes.outputs.compose == 'true' }}
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.PROD_SERVER_HOST }} << 'EOF'
            set +e
            echo "üîé Checking pgadmin-production container..."
            docker ps --format '{{.Names}} {{.Ports}}' | grep -q '^pgadmin-production ' || { echo '‚ùå pgadmin-production n√£o est√° rodando'; docker logs --tail=200 pgadmin-production || true; }

            echo "üîé Detectando porta mapeada de pgAdmin"
            PORT=$(docker inspect -f '{{range $i, $p := .NetworkSettings.Ports}}{{if eq $i "80/tcp"}}{{(index $p 0).HostPort}}{{end}}{{end}}' pgadmin-production 2>/dev/null)
            [ -z "$PORT" ] && PORT=5050
            echo "üîé Porta detectada: $PORT"

            echo "üîé Curling pgAdmin endpoint (127.0.0.1:$PORT) com retries"
            ATTEMPTS=20; SLEEP=3; CODE=""
            for i in \
              $(seq 1 $ATTEMPTS); do
              if command -v curl >/dev/null 2>&1; then
                CODE=$(curl -sS -o /dev/null -w "%{http_code}" --max-time 3 --connect-timeout 3 --retry 2 --retry-connrefused http://127.0.0.1:"$PORT"/ || true)
              else
                CODE=$(wget --server-response -q -O - http://127.0.0.1:"$PORT"/ 2>&1 | awk '/^  HTTP/{print $2}' | tail -n1)
              fi
              echo "Tentativa #$i ‚Äî HTTP: $CODE"
              if [ "$CODE" = "200" ] || [ "$CODE" = "302" ] || [ "$CODE" = "307" ] || [ "$CODE" = "308" ]; then
                echo "‚úÖ pgAdmin responde"
                break
              fi
              sleep $SLEEP
            done
            docker logs --tail=120 pgadmin-production || true

            echo "üîê Abrindo firewall para porta $PORT (se necess√°rio)"
            if command -v ufw >/dev/null 2>&1; then
              ufw allow "$PORT"/tcp || true
              ufw allow 80/tcp || true
              ufw status || true
            else
              iptables -C INPUT -p tcp --dport "$PORT" -j ACCEPT 2>/dev/null || iptables -I INPUT -p tcp --dport "$PORT" -j ACCEPT || true
              iptables -C INPUT -p tcp --dport 80 -j ACCEPT 2>/dev/null || iptables -I INPUT -p tcp --dport 80 -j ACCEPT || true
              iptables -L -n | grep "$PORT" || true
            fi

            # N√£o falhar o job por sa√∫de do pgAdmin; prosseguir com deploy do app
            exit 0
          EOF

      - name: üéâ Deployment complete
        run: |
          echo "üöÄ Deployment completed successfully!"
          echo "üåê Application available at: http://${{ secrets.PROD_SERVER_HOST }}:3001"
          echo "üóÑÔ∏è PostgreSQL running on port 5434 with persistent volume"
          echo "üîß pgAdmin4 available at: http://${{ secrets.PROD_SERVER_HOST }}:5050"
          echo "üìß pgAdmin Login: definido pelo env PGADMIN_DEFAULT_EMAIL/PGADMIN_DEFAULT_PASSWORD"
          echo "üîê App Login: usu√°rio administrador configurado via vari√°veis de ambiente"
