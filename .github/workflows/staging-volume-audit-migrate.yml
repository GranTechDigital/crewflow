name: Staging Postgres Volume Audit/Migrate

on:
  workflow_dispatch:
    inputs:
      mode:
        description: 'Modo de execu√ß√£o: audit (somente checa) ou migrate (migra com backup)'
        type: choice
        required: true
        options:
          - audit
          - migrate
        default: audit
      confirm_env:
        description: 'Confirma√ß√£o de ambiente (digite exatamente: staging)'
        type: string
        required: true
        default: staging
      dry_run:
        description: 'Dry run (true = n√£o altera nada, apenas simula; false = aplica) ‚Äî s√≥ tem efeito no modo migrate'
        type: boolean
        required: true
        default: true

jobs:
  audit_migrate:
    runs-on: ubuntu-latest
    steps:
      - name: üîë Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: üîé Audit/Migrate staging volume
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -euo pipefail

            if [ "${{ github.event.inputs.confirm_env }}" != "staging" ]; then
              echo "‚ùå confirm_env inv√°lido (use: staging)"; exit 1; fi

            MODE="${{ github.event.inputs.mode }}"
            DRY_RUN="${{ github.event.inputs.dry_run }}"

            CONTAINER="postgres-staging"
            TARGET_LOGICAL_NAME="postgres-staging-data"  # nome l√≥gico do compose
            TARGET_VOLUME_NAME="projetogran_${TARGET_LOGICAL_NAME}"  # nome f√≠sico do volume no Docker
            DATA_MOUNT="/var/lib/postgresql/data"

            echo "üîé Detectando volume atual do container: $CONTAINER"
            if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER}$"; then
              CURRENT_VOLUME=$(docker inspect ${CONTAINER} --format '{{ range .Mounts }}{{ if eq .Destination "${DATA_MOUNT}" }}{{ .Name }}{{ end }}{{ end }}')
            else
              CURRENT_VOLUME=""
            fi
            echo "üì¶ Volume atual detectado: ${CURRENT_VOLUME:-<nenhum>}"
            echo "üéØ Volume alvo padronizado: ${TARGET_VOLUME_NAME} (l√≥gico: ${TARGET_LOGICAL_NAME})"

            if [ -z "${CURRENT_VOLUME}" ]; then
              echo "‚ö†Ô∏è Container ${CONTAINER} n√£o existe ou n√£o tem mount em ${DATA_MOUNT}. Tentando descobrir poss√≠veis volumes..."
              docker volume ls
            fi

            if [ "${CURRENT_VOLUME}" = "${TARGET_VOLUME_NAME}" ]; then
              echo "‚úÖ J√° est√° padronizado usando ${TARGET_VOLUME_NAME}. Nada a fazer."
              exit 0
            fi

            if [ "${MODE}" = "audit" ]; then
              echo "‚ÑπÔ∏è Modo audit: diferen√ßa encontrada. Volume atual='${CURRENT_VOLUME}', alvo='${TARGET_VOLUME_NAME}'. Sem altera√ß√µes."
              exit 0
            fi

            echo "üõ°Ô∏è Modo migrate: preparando backup antes de qualquer altera√ß√£o..."
            mkdir -p /var/backups/projetogran/staging
            TS=$(date -u +%Y%m%d_%H%M%S)
            FILE="/var/backups/projetogran/staging/projetogran_${TS}.dump"
            if docker ps --format '{{.Names}}' | grep -q '^postgres-staging$'; then
              echo "üîé Sanity-check container e DB antes do dump..."
              docker exec postgres-staging psql -U postgres -d projetogran -tAc "SELECT current_database();" | grep -q '^projetogran$' || { echo '‚ùå Conex√£o ao DB projetogran falhou'; exit 1; }
              echo "üíæ Criando backup (pg_dump -Fc) em $FILE"
              docker exec postgres-staging pg_dump -U postgres -d projetogran -Fc > "$FILE"
              ls -lh "$FILE" || true
              if [ ! -s "$FILE" ]; then echo "‚ùå Backup vazio ou n√£o encontrado: $FILE"; exit 1; fi
              echo "‚úÖ Backup criado: $FILE"
            else
              echo "‚ö†Ô∏è Container postgres-staging n√£o est√° em execu√ß√£o; pulando backup via pg_dump."
            fi

            if [ "${DRY_RUN}" = "true" ]; then
              echo "üß™ Dry run habilitado ‚Äî nenhuma altera√ß√£o ser√° aplicada."
              echo "üëâ A migra√ß√£o faria: parar ${CONTAINER}, criar volume ${TARGET_VOLUME_NAME}, copiar dados de ${CURRENT_VOLUME} -> ${TARGET_VOLUME_NAME}, subir compose, validar DB."
              exit 0
            fi

            echo "‚èπÔ∏è Parando container ${CONTAINER} para copiar dados com consist√™ncia..."
            docker stop ${CONTAINER} 2>/dev/null || true

            echo "üì¶ Garantindo exist√™ncia do volume alvo: ${TARGET_VOLUME_NAME}"
            docker volume inspect ${TARGET_VOLUME_NAME} >/dev/null 2>&1 || docker volume create ${TARGET_VOLUME_NAME}

            if [ -z "${CURRENT_VOLUME}" ]; then
              echo "‚ùå N√£o foi poss√≠vel determinar o volume atual para copiar. Abortando."
              exit 1
            fi

            echo "üìÅ Copiando dados: ${CURRENT_VOLUME} -> ${TARGET_VOLUME_NAME}"
            docker run --rm \
              -v ${CURRENT_VOLUME}:/from \
              -v ${TARGET_VOLUME_NAME}:/to \
              alpine sh -c "set -e; cd /from && cp -a . /to"

            echo "üîé Validando c√≥pia (arquivos essenciais)..."
            docker run --rm -v ${TARGET_VOLUME_NAME}:/to alpine sh -lc "ls -al /to | head -n 50; [ -f /to/PG_VERSION ] || { echo '‚ùå Arquivo PG_VERSION n√£o encontrado no volume alvo'; exit 1; }"

            echo "üöÄ Subindo Postgres de staging com compose e volume padronizado"
            docker network create projetogran_crewflow-network 2>/dev/null || true
            cd /opt/projetogran
            if docker compose version >/dev/null 2>&1; then
              docker compose -f docker-compose.staging-postgres.yml down || true
              docker compose -f docker-compose.staging-postgres.yml up -d
            else
              echo "‚ùå Docker Compose v2 n√£o encontrado (instale previamente)."; exit 125
            fi

            echo "‚è≥ Aguardando Postgres inicializar..."
            sleep 8
            docker ps | grep -q '^postgres-staging' || { echo '‚ùå postgres-staging n√£o subiu'; docker ps -a; exit 1; }

            echo "üß™ Testando conex√£o ao DB 'projetogran'"
            docker exec postgres-staging psql -U postgres -d projetogran -tAc "SELECT current_database();" | grep -q '^projetogran$' || { echo '‚ùå Conex√£o ao DB projetogran falhou ap√≥s migra√ß√£o'; exit 1; }

            echo "üîé Confer√™ncia de integridade m√≠nima (ex.: contagem de tabelas Prisma)"
            docker exec postgres-staging psql -U postgres -d projetogran -tAc "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public';" | awk '{print "Qtd. tabelas public:", $1}'

            echo "‚úÖ Migra√ß√£o conclu√≠da. Volume atual agora deve ser: ${TARGET_VOLUME_NAME}"
            echo "‚ÑπÔ∏è Volume antigo preservado (${CURRENT_VOLUME}) para rollback manual, se necess√°rio. Remova-o depois de validar tudo:"
            echo "   docker volume rm ${CURRENT_VOLUME}"
          EOF

      - name: üìã Resumo
        run: |
          echo "Modo: ${{ github.event.inputs.mode }}"
          echo "Dry run: ${{ github.event.inputs.dry_run }}"
          echo "Confirm env: ${{ github.event.inputs.confirm_env }}"