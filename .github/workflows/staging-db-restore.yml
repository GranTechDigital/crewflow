name: Staging DB Restore

on:
  workflow_dispatch:
    inputs:
      dump_path:
        description: 'Caminho absoluto do dump no servidor (ex.: /var/backups/projetogran/staging/projetogran_YYYYmmdd_HHMMSS.dump ou .sql)'
        type: string
        required: true
      db_name:
        description: 'Nome do banco de dados de destino'
        type: string
        required: true
        default: 'projetogran'
      confirm_env:
        description: 'Confirma√ß√£o de ambiente (digite exatamente: staging)'
        type: string
        required: true
        default: 'staging'
      restart_app:
        description: 'Reiniciar o app de staging ap√≥s restaurar'
        type: boolean
        required: true
        default: true
      min_dump_size_bytes:
        description: 'Tamanho m√≠nimo esperado do dump, em bytes (string). Use 1000000 para 1MB).'
        type: string
        required: false
        default: '1000000'
      apply_migrations:
        description: 'Aplicar npx prisma migrate deploy ap√≥s restaurar'
        type: boolean
        required: false
        default: true

jobs:
  restore:
    runs-on: ubuntu-latest
    steps:
      - name: üîë Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: üóÑÔ∏è Restaurar dump no Postgres de staging
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -euo pipefail

            if [ "${{ github.event.inputs.confirm_env }}" != "staging" ]; then
              echo "‚ùå confirm_env inv√°lido (use: staging)"; exit 1; fi

            DUMP="${{ github.event.inputs.dump_path }}"
            DB_NAME="${{ github.event.inputs.db_name }}"
            RESTART="${{ github.event.inputs.restart_app }}"
            MIN_SIZE="${{ github.event.inputs.min_dump_size_bytes }}"
            APPLY_MIGRATIONS="${{ github.event.inputs.apply_migrations }}"

            echo "üîé Sele√ß√£o/valida√ß√£o do arquivo de dump"
            # Normaliza MIN_SIZE para n√∫mero; se inv√°lido, usa 0 e avisa
            if echo "$MIN_SIZE" | grep -Eq '^[0-9]+$'; then
              MIN_SIZE_NUM="$MIN_SIZE"
            else
              echo "‚ö†Ô∏è min_dump_size_bytes n√£o num√©rico ('$MIN_SIZE'); usando 0 (sem guarda de tamanho)."
              MIN_SIZE_NUM=0
            fi

            choose_dump() {
              local req="$1"
              local min="$2"
              if [ -f "$req" ]; then
                local s=$(stat -c%s "$req" || echo 0)
                if [ "$s" -ge "$min" ]; then
                  echo "$req"; return 0
                else
                  echo "‚ÑπÔ∏è Dump solicitado muito pequeno (${s} bytes < ${min}); tentando selecionar automaticamente..." >&2
                fi
              else
                echo "‚ÑπÔ∏è Dump solicitado n√£o encontrado: $req; tentando selecionar automaticamente..." >&2
              fi
              # Tenta maiores que o m√≠nimo
              local cand=$(for f in /var/backups/projetogran/staging/*.dump /var/backups/projetogran/staging/*.sql; do
                               [ -e "$f" ] || continue; s=$(stat -c%s "$f" || echo 0); echo "$s $f";
                             done | sort -nr | awk -v m="$min" '$1>=m {print $2; exit}')
              if [ -n "$cand" ]; then echo "$cand"; return 0; fi
              # Sem candidatos >= min, pega o maior dispon√≠vel (com aviso)
              cand=$(for f in /var/backups/projetogran/staging/*.dump /var/backups/projetogran/staging/*.sql; do
                               [ -e "$f" ] || continue; s=$(stat -c%s "$f" || echo 0); echo "$s $f";
                             done | sort -nr | awk 'NR==1{print $2}')
              if [ -n "$cand" ]; then
                echo "‚ö†Ô∏è Nenhum dump >= ${min} bytes; usando o maior dispon√≠vel: $cand" >&2
                echo "$cand"; return 0
              fi
              return 1
            }

            DUMP=$(choose_dump "$DUMP" "$MIN_SIZE_NUM") || { echo "‚ùå Nenhum dump v√°lido encontrado para restaurar"; exit 1; }
            echo "üì¶ Dump selecionado:"; ls -lh "$DUMP" || true
            SIZE=$(stat -c%s "$DUMP" || echo 0); echo "SIZE=${SIZE}"

            echo "‚èπÔ∏è Parando app de staging para evitar conex√µes durante o restore..."
            docker ps --format '{{.Names}}' | grep -E '^(crewflow-app-staging|app-staging)$' | xargs -r -I{} docker stop {}

            echo "üíæ Criando backup pr√©-restore do DB atual (formato custom -Fc)..."
            mkdir -p /var/backups/projetogran/staging
            TS=$(date -u +%Y%m%d_%H%M%S)
            PRE="/var/backups/projetogran/staging/${DB_NAME}_pre_restore_${TS}.dump"
            docker exec postgres-staging bash -lc "export PGPASSWORD=\"\$POSTGRES_PASSWORD\"; pg_dump -U \"\$POSTGRES_USER\" -d \"$DB_NAME\" -Fc" > "$PRE"
            ls -lh "$PRE" || true
            if [ ! -s "$PRE" ]; then echo "‚ùå Backup pr√©-restore vazio ou inv√°lido: $PRE"; exit 3; fi
            echo "‚úÖ Backup pr√©-restore criado: $PRE"

            echo "üîß Derrubando conex√µes e recriando DB limpo ($DB_NAME)"
            docker exec postgres-staging psql -U postgres -tAc "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname='${DB_NAME}';" || true
            docker exec postgres-staging psql -U postgres -v ON_ERROR_STOP=1 -c "DROP DATABASE IF EXISTS \"${DB_NAME}\";"
            docker exec postgres-staging psql -U postgres -v ON_ERROR_STOP=1 -c "CREATE DATABASE \"${DB_NAME}\" TEMPLATE template0 ENCODING 'UTF8';"

            echo "üì¶ Restaurando dump em ${DB_NAME}"
            EXT="${DUMP##*.}"
            if [ "$EXT" = "sql" ]; then
              echo "‚Ü™Ô∏è Detetado dump SQL (texto). Usando psql < arquivo."
              cat "$DUMP" | docker exec -i postgres-staging bash -lc "export PGPASSWORD=\"\$POSTGRES_PASSWORD\"; psql -U \"\$POSTGRES_USER\" -d \"$DB_NAME\""
            else
              echo "‚Ü™Ô∏è Detetado dump em formato custom/dir/tar. Usando pg_restore."
              cat "$DUMP" | docker exec -i postgres-staging bash -lc "export PGPASSWORD=\"\$POSTGRES_PASSWORD\"; pg_restore -U \"\$POSTGRES_USER\" -d \"$DB_NAME\" --clean --if-exists --no-owner --no-privileges"
            fi
            echo "‚úÖ Restore conclu√≠do."

            echo "üß™ Validando conex√£o e contagem de tabelas"
            docker exec postgres-staging psql -U postgres -d "$DB_NAME" -tAc "SELECT current_database();" | grep -q "^${DB_NAME}$" || { echo '‚ùå Conex√£o falhou p√≥s-restore'; exit 4; }
            TABLES=$(docker exec postgres-staging psql -U postgres -d "$DB_NAME" -tAc "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public';" | tr -d '[:space:]')
            echo "Qtd. tabelas public: ${TABLES:-0}"
            if [ -z "$TABLES" ] || [ "$TABLES" -eq 0 ]; then
              echo "‚ùå Nenhuma tabela encontrada ap√≥s o restore; abortando."; exit 4;
            fi

            if [ "$RESTART" = "true" ]; then
              echo "üöÄ Reiniciando app de staging..."
              APP_CTN=$(docker ps -a --format '{{.Names}}' | grep -E '^(crewflow-app-staging|app-staging)$' | head -n1 || true)
              if [ -n "$APP_CTN" ]; then
                docker start "$APP_CTN" || true
                if [ "${APPLY_MIGRATIONS:-true}" = "true" ]; then
                  echo "üîß Aplicando migra√ß√µes (idempotentes)..."
                  docker exec "$APP_CTN" sh -lc "npx prisma migrate deploy || true" || true
                fi
                echo "üîé DATABASE_URL efetiva do app:"
                docker inspect -f '{{range .Config.Env}}{{println .}}{{end}}' "$APP_CTN" | grep DATABASE_URL || true
              else
                echo "‚ö†Ô∏è Container do app de staging n√£o encontrado; pulando start/migrations."
              fi
            else
              echo "‚ÑπÔ∏è restart_app=false ‚Äî n√£o reiniciando app automaticamente."
            fi

            echo "‚úÖ Processo finalizado com sucesso."
          EOF

      - name: üìã Resumo
        run: |
          echo "dump_path: ${{ github.event.inputs.dump_path }}"
          echo "db_name: ${{ github.event.inputs.db_name }}"
          echo "confirm_env: ${{ github.event.inputs.confirm_env }}"
          echo "restart_app: ${{ github.event.inputs.restart_app }}"
          echo "min_dump_size_bytes: ${{ github.event.inputs.min_dump_size_bytes }}"
          echo "apply_migrations: ${{ github.event.inputs.apply_migrations }}"