name: Deploy CrewFlow to Staging

on:
  push:
    branches: [develop, staging]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      run_name:
        description: 'Nome do run (opcional) ‚Äî deixe vazio para usar branch/autor'
        type: string
        required: false
      skip_db_backup:
        description: 'Pular backup do banco antes do deploy? (false recomendado)'
        type: boolean
        required: false
        default: false

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîß Build Docker image
        run: |
          docker build --no-cache -t crewflow-app:staging .

      - name: üíæ Save Docker image
        run: |
          docker save crewflow-app:staging > crewflow-app-staging.tar

      - name: üîë Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: üíæ Backup do banco de dados (staging) antes do deploy
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_db_backup != 'true' }}
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e
            mkdir -p /var/backups/projetogran/staging
            TS=$(date -u +%Y%m%d_%H%M%S)
            FILE="/var/backups/projetogran/staging/projetogran_${TS}.dump"
            echo "üîé Sanity-check container e DB antes do dump..."
            docker ps --format '{{.Names}}' | grep -q '^postgres-staging$' || { echo '‚ùå Container postgres-staging n√£o est√° em execu√ß√£o'; exit 1; }
            # Descobrir usu√°rio/senha primeiro; evitar defaults inseguros (ex.: 'root')
            DB_USER=$(docker exec postgres-staging bash -lc 'echo -n "${POSTGRES_USER:-postgres}"')
            DB_PASS=$(docker exec postgres-staging bash -lc 'echo -n "${POSTGRES_PASSWORD:-}"')
            [ -z "$DB_PASS" ] && DB_PASS="${{ secrets.POSTGRES_PASSWORD }}"
            [ -z "$DB_PASS" ] && DB_PASS="postgres"
            # Descobrir DB de trabalho: priorizar maior DB n√£o-template; fallback para POSTGRES_DB
            DB_NAME=$(docker exec postgres-staging env PGPASSWORD="$DB_PASS" psql -h localhost -U "$DB_USER" -d postgres -tAc "SELECT datname FROM pg_database WHERE datistemplate = false AND datname NOT IN ('postgres') ORDER BY pg_database_size(datname) DESC LIMIT 1;" | tr -d "\r\n")
            if [ -z "$DB_NAME" ]; then
              DB_NAME=$(docker exec postgres-staging bash -lc 'echo -n "${POSTGRES_DB:-projetogran}"')
            fi
            [ -z "$DB_PASS" ] && DB_PASS="${{ secrets.POSTGRES_PASSWORD }}"
            [ -z "$DB_PASS" ] && DB_PASS="postgres"
            echo "üîé Validando conex√£o ao DB '${DB_NAME}' com usu√°rio '${DB_USER}'..."
            docker exec postgres-staging env PGPASSWORD="$DB_PASS" psql -h localhost -U "$DB_USER" -d "$DB_NAME" -tAc "SELECT current_database();" | grep -q "^${DB_NAME}$" || { echo "‚ùå Conex√£o ao DB ${DB_NAME} falhou"; exit 1; }
            echo "üîé Realizando pg_dump (custom format) do banco '${DB_NAME}'..."
            docker exec postgres-staging env PGPASSWORD="$DB_PASS" pg_dump -h localhost -U "$DB_USER" -d "$DB_NAME" -Fc > "$FILE"
            ls -lh "$FILE" || true
            # Guard rail: validar arquivo gerado (n√£o-vazio)
            if [ ! -s "$FILE" ]; then
              echo "‚ùå Backup vazio ou n√£o encontrado: $FILE"; exit 1; fi
            echo "‚úÖ Backup criado: $FILE"
            # Reten√ß√£o opcional: manter apenas 30 backups mais recentes
            ls -1t /var/backups/projetogran/staging/projetogran_*.dump | tail -n +31 | xargs -r rm -f
          EOF

      - name: üì§ Upload image and compose to server
        run: |
          # Clean up any existing staging tar file first
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} "rm -f /tmp/crewflow-app-staging.tar"

          # Upload new image
          scp -o StrictHostKeyChecking=no crewflow-app-staging.tar root@${{ secrets.SERVER_HOST }}:/tmp/

          # Ensure application directory exists and upload staging Postgres compose
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} "mkdir -p /opt/projetogran"
          scp -o StrictHostKeyChecking=no docker-compose.staging-postgres.yml root@${{ secrets.SERVER_HOST }}:/opt/projetogran/
          # Garantir .env.staging com vari√°veis obrigat√≥rias a partir dos Secrets (staging)
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOS'
            set -e
            POSTGRES_PASSWORD_VALUE='${{ secrets.POSTGRES_PASSWORD }}'
            PGADMIN_EMAIL_VALUE='${{ secrets.PGADMIN_EMAIL }}'
            PGADMIN_PASSWORD_VALUE='${{ secrets.PGADMIN_PASSWORD }}'
            ENV_FILE=/opt/projetogran/.env.staging
            mkdir -p /opt/projetogran
            [ -f "$ENV_FILE" ] || touch "$ENV_FILE"
            chmod 600 "$ENV_FILE"
            # Defaults se secrets vazios
            [ -z "$POSTGRES_PASSWORD_VALUE" ] && POSTGRES_PASSWORD_VALUE=postgres
            [ -z "$PGADMIN_EMAIL_VALUE" ] && PGADMIN_EMAIL_VALUE=admin@gransystem.com
            [ -z "$PGADMIN_PASSWORD_VALUE" ] && PGADMIN_PASSWORD_VALUE=admin123
            ensure_var() {
              key="$1"; val="$2"
              if grep -q "^${key}=" "$ENV_FILE"; then
                sed -i "s/^${key}=.*/${key}=${val}/" "$ENV_FILE"
              else
                echo "${key}=${val}" >> "$ENV_FILE"
              fi
            }
            ensure_var POSTGRES_USER postgres
            ensure_var POSTGRES_PASSWORD "$POSTGRES_PASSWORD_VALUE"
            ensure_var POSTGRES_DB projetogran
            ensure_var PGADMIN_DEFAULT_EMAIL "$PGADMIN_EMAIL_VALUE"
            ensure_var PGADMIN_DEFAULT_PASSWORD "$PGADMIN_PASSWORD_VALUE"
          EOS
      - name: üöÄ Deploy to staging
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e
            # Clean up Docker system before deployment
            docker system prune -f || true

            # Load new image
            docker load < /tmp/crewflow-app-staging.tar

            # Ensure Postgres staging is up via compose
            docker network create projetogran_crewflow-network 2>/dev/null || true
            cd /opt/projetogran
            docker rm -f postgres-staging 2>/dev/null || true
            docker rm -f pgadmin-staging 2>/dev/null || true
            if docker compose version >/dev/null 2>&1; then
              docker compose --env-file /opt/projetogran/.env.staging -f /opt/projetogran/docker-compose.staging-postgres.yml down || true
              docker compose --env-file /opt/projetogran/.env.staging -f /opt/projetogran/docker-compose.staging-postgres.yml up -d
            else
              echo "‚ÑπÔ∏è Docker Compose v2 not found. Installing plugin..."
              ARCH=$(uname -m)
              COMPOSE_URL=""
              if [ "$ARCH" = "x86_64" ]; then
                COMPOSE_URL="https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64"
              elif [ "$ARCH" = "aarch64" ]; then
                COMPOSE_URL="https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-aarch64"
              elif [ "$ARCH" = "armv7l" ]; then
                COMPOSE_URL="https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-armv7"
              else
                echo "‚ùå Unsupported architecture: $ARCH"
                uname -a || true
                exit 125
              fi
              mkdir -p ~/.docker/cli-plugins
              if command -v curl >/dev/null 2>&1; then
                curl -fsSL "$COMPOSE_URL" -o ~/.docker/cli-plugins/docker-compose
              elif command -v wget >/dev/null 2>&1; then
                wget -qO ~/.docker/cli-plugins/docker-compose "$COMPOSE_URL"
              else
                echo "‚ùå Neither curl nor wget is available to download Docker Compose."
                exit 125
              fi
              chmod +x ~/.docker/cli-plugins/docker-compose
              if docker compose version >/dev/null 2>&1; then
                echo "‚úÖ Docker Compose v2 installed."
              else
                echo "‚ùå Failed to install Docker Compose v2."
                exit 125
              fi
              docker compose --env-file /opt/projetogran/.env.staging -f /opt/projetogran/docker-compose.staging-postgres.yml down || true
              docker compose --env-file /opt/projetogran/.env.staging -f /opt/projetogran/docker-compose.staging-postgres.yml up -d
            fi

            # Stop and remove old staging container
            docker stop crewflow-app-staging 2>/dev/null || true
            docker rm crewflow-app-staging 2>/dev/null || true

            # Montar DATABASE_URL preferindo o maior DB existente (n√£o-template); fallback para POSTGRES_DB
            DB_NAME=$(docker exec postgres-staging bash -lc 'export PGPASSWORD="$POSTGRES_PASSWORD"; psql -h localhost -U "$POSTGRES_USER" -d postgres -tAc "SELECT datname FROM pg_database WHERE datistemplate = false AND datname NOT IN ('\''postgres'\'') ORDER BY pg_database_size(datname) DESC LIMIT 1;" | tr -d "\r\n"')
            if [ -z "$DB_NAME" ]; then
              DB_NAME=$(docker exec postgres-staging bash -lc 'echo -n "${POSTGRES_DB:-projetogran}"')
            fi
            # Usu√°rio do DB
            DB_USER=$(docker exec postgres-staging bash -lc 'echo -n "${POSTGRES_USER:-postgres}"')
            # Descobrir senha v√°lida testando candidatos (env do container, secret do Actions, default)
            CANDIDATE_ENV=$(docker exec postgres-staging bash -lc 'echo -n "${POSTGRES_PASSWORD:-}"')
            CANDIDATE_SECRET='${{ secrets.POSTGRES_PASSWORD }}'
            CANDIDATE_DEFAULT='postgres'
            DB_PASS=""
            for CAND in "$CANDIDATE_ENV" "$CANDIDATE_SECRET" "$CANDIDATE_DEFAULT"; do
              if [ -n "$CAND" ]; then
                if docker exec postgres-staging env PGPASSWORD="$CAND" psql -h localhost -U "$DB_USER" -d "$DB_NAME" -tAc "SELECT 1;" >/dev/null 2>&1; then
                  DB_PASS="$CAND"; break
                fi
              fi
            done
            if [ -z "$DB_PASS" ]; then
              echo "‚ùå N√£o foi poss√≠vel validar credenciais do Postgres (todas candidatas falharam)."; exit 1
            fi
            # Codificar credenciais para URL (evita quebra com caracteres especiais)
            urlencode() {
              local LANG=C s="$1" i c out=""
              for ((i=0; i<${#s}; i++)); do
                c=${s:i:1}
                case "$c" in [a-zA-Z0-9.~_-]) out+="$c" ;; *)
                  printf -v hex '%02X' "'$c" 
                  out+="%$hex"
                esac
              done
              echo -n "$out"
            }
            DB_USER_ENC="$(urlencode "$DB_USER")"
            DB_PASS_ENC="$(urlencode "$DB_PASS")"
            DATABASE_URL="postgresql://${DB_USER_ENC}:${DB_PASS_ENC}@postgres-staging:5432/${DB_NAME}?schema=public"
            # Gerar JWT_SECRET e CLEANUP_ADMIN_TOKEN ef√™meros
            if command -v openssl >/dev/null 2>&1; then
              JWT_SECRET=$(openssl rand -hex 32)
              CLEANUP_ADMIN_TOKEN=$(openssl rand -hex 32)
            else
              JWT_SECRET=$(date +%s%N | sha256sum | cut -c1-64)
              CLEANUP_ADMIN_TOKEN=$(date +%s%N | sha256sum | cut -c1-64)
            fi

            # Start new staging container (different port, correct internal port)
            docker run -d --name crewflow-app-staging \
              --network projetogran_crewflow-network \
              -p 3002:3001 \
              -e DATABASE_URL="$DATABASE_URL" \
              -e JWT_SECRET="$JWT_SECRET" \
              -e NEXTAUTH_URL='http://${{ secrets.SERVER_HOST }}:3002' \
              -e NODE_ENV='production' \
              -e CLEANUP_ADMIN_TOKEN="$CLEANUP_ADMIN_TOKEN" \
              crewflow-app:staging

            # Clean up
            rm /tmp/crewflow-app-staging.tar

            # Wait for container to start
            sleep 10

            # Check if container is running
            if docker ps | grep -q crewflow-app-staging; then
              echo "‚úÖ Staging container started successfully"
            else
              echo "‚ùå Staging container failed to start"
              docker logs crewflow-app-staging
              exit 1
            fi

            # Setup Prisma inside container (fail on error)
            docker exec crewflow-app-staging npx prisma generate
            # Ensure migration_lock provider is Postgres
            docker exec crewflow-app-staging sh -lc "if grep -q 'provider = \"sqlite\"' prisma/migrations/migration_lock.toml; then echo '‚ö†Ô∏è Fixing migration_lock provider from sqlite to postgresql'; printf '# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = \"postgresql\"\n' > prisma/migrations/migration_lock.toml; fi; echo 'üîé Current migration_lock:'; cat prisma/migrations/migration_lock.toml"

            # Baseline check: mark init as applied only if DB already has migration table
            echo "üîé Checking migration baseline in Postgres (_prisma_migrations)..."
            MIG_TABLE_EXISTS=$(docker exec postgres-staging bash -lc "export PGPASSWORD=\"$DB_PASS\"; psql -U \"$DB_USER\" -d \"$DB_NAME\" -tAc \"SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='_prisma_migrations');\"")
            # Se n√£o tem _prisma_migrations mas j√° existem tabelas, marcar baseline como aplicada (n√£o destruir dados)
            HAS_TABLES=$(docker exec postgres-staging bash -lc "export PGPASSWORD=\"$DB_PASS\"; psql -U \"$DB_USER\" -d \"$DB_NAME\" -tAc \"SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public' AND table_type='BASE TABLE';\"")
            if [ "$MIG_TABLE_EXISTS" != "t" ] && [ "${HAS_TABLES:-0}" -gt 0 ]; then
              echo "‚ÑπÔ∏è Detected existing tables without _prisma_migrations. Marking baseline as applied."
              docker exec crewflow-app-staging npx prisma migrate resolve --applied "20251013111730_init" || true
            fi
            if [ "$MIG_TABLE_EXISTS" = "t" ]; then
              INIT_APPLIED=$(docker exec postgres-staging bash -lc "export PGPASSWORD=\"$DB_PASS\"; psql -U \"$DB_USER\" -d \"$DB_NAME\" -tAc \"SELECT EXISTS (SELECT 1 FROM public._prisma_migrations WHERE migration_name = '20251013111730_init');\"")
              if [ "$INIT_APPLIED" != "t" ]; then
                echo "‚ÑπÔ∏è Marking baseline migration '20251013111730_init' as applied (existing DB)"
                docker exec crewflow-app-staging npx prisma migrate resolve --applied "20251013111730_init" || true
              else
                echo "‚úÖ Baseline migration already applied"
              fi
            else
              echo "‚ÑπÔ∏è Either baseline was marked above or fresh database. Proceeding with migrate deploy."
            fi

            # Apply Postgres migrations only
            docker exec crewflow-app-staging npx prisma migrate deploy
            
            # Conditionally run seed only if database is empty (avoid overwriting migrated data)
            # Seed idempotente
            echo "üå± Seeding database (idempotente) ..."
            if docker exec crewflow-app-staging npm run seed:complete 2>/dev/null; then
              echo "‚úÖ Seed aplicado ou ignorado de forma segura (idempotente)"
            else
              echo "‚ÑπÔ∏è Seed falhou ou foi ignorado; verificar logs do container se necess√°rio"
            fi

            # Verify tables exist
            echo "üîé Verificando tabelas no banco..."
            docker exec postgres-staging bash -lc "export PGPASSWORD=\"\$POSTGRES_PASSWORD\"; psql -U \"\$POSTGRES_USER\" -d \"$DB_NAME\" -c \"\\dt\""
          EOF

      - name: üß™ Run tests (optional)
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            # Basic health check
            sleep 5
            if curl -f http://localhost:3002/api/health 2>/dev/null; then
              echo "‚úÖ Health check passed"
            else
              echo "‚ö†Ô∏è Health check failed (normal if no health endpoint)"
            fi
          EOF

      - name: üìù Comment PR (if PR)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `üöÄ **CrewFlow Staging Deploy Successful!**
              
              üìç **Staging URL:** http://${{ secrets.SERVER_HOST }}:3002
              -              üîê **Login:** ADMIN001 / admin123
              +              üîê **Login:** usu√°rio administrador configurado via ambiente
              
              ‚úÖ Ready for testing!`
            })

      - name: üéâ Staging deployment complete
        run: |
          echo "üöÄ CrewFlow staging deployment completed successfully!"
          echo "üåê Staging available at: http://${{ secrets.SERVER_HOST }}:3002"
          echo "üîê Login: usu√°rio administrador configurado via vari√°veis de ambiente"