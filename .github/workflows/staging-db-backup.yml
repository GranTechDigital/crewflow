name: Staging DB Backup

on:
  workflow_dispatch:
    inputs:
      confirm_env:
        description: 'ConfirmaÃ§Ã£o de ambiente (digite exatamente: staging)'
        type: string
        required: true
        default: 'staging'
      min_dump_size_bytes:
        description: 'Tamanho mÃ­nimo esperado do dump, em bytes (string). Use 1000000 para 1MB).'
        type: string
        required: false
        default: '1000000'
      upload_artifact:
        description: 'Fazer download do dump e publicar como artifact'
        type: boolean
        required: false
        default: true

jobs:
  backup:
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: ğŸ”‘ Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸ’¾ Backup do banco de dados (staging) com timestamp
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} << 'EOF'
            set -euo pipefail

            if [ "${{ github.event.inputs.confirm_env }}" != "staging" ]; then
              echo "âŒ confirm_env invÃ¡lido (use: staging)"; exit 1; fi

            mkdir -p /var/backups/projetogran/staging
            TS=$(date -u +%Y%m%d_%H%M%S)
            FILE="/var/backups/projetogran/staging/projetogran_${TS}.dump"

            echo "ğŸ” Sanity-check container e DB antes do dump..."
            docker ps --format '{{.Names}}' | grep -q '^postgres-staging$' || { echo 'âŒ Container postgres-staging nÃ£o estÃ¡ em execuÃ§Ã£o'; exit 1; }

            # Descobrir usuÃ¡rio/senha primeiro; evitar defaults inseguros (ex.: 'root')
            DB_USER=$(docker exec postgres-staging bash -lc 'echo -n "${POSTGRES_USER:-postgres}"')
            DB_PASS=$(docker exec postgres-staging bash -lc 'echo -n "${POSTGRES_PASSWORD:-}"')
            [ -z "$DB_PASS" ] && DB_PASS="${{ secrets.POSTGRES_PASSWORD }}"
            [ -z "$DB_PASS" ] && DB_PASS="postgres"

            # Descobrir DB de trabalho: priorizar maior DB nÃ£o-template; fallback para POSTGRES_DB
            DB_NAME=$(docker exec postgres-staging env PGPASSWORD="$DB_PASS" psql -h localhost -U "$DB_USER" -d postgres -tAc "SELECT datname FROM pg_database WHERE datistemplate = false AND datname NOT IN ('postgres') ORDER BY pg_database_size(datname) DESC LIMIT 1;" | tr -d "\r\n")
            if [ -z "$DB_NAME" ]; then
              DB_NAME=$(docker exec postgres-staging bash -lc 'echo -n "${POSTGRES_DB:-projetogran}"')
            fi

            echo "ğŸ” Validando conexÃ£o ao DB '$DB_NAME' com usuÃ¡rio '$DB_USER'..."
            docker exec postgres-staging env PGPASSWORD="$DB_PASS" psql -h localhost -U "$DB_USER" -d "$DB_NAME" -tAc "SELECT current_database();" | grep -q "^${DB_NAME}$" || { echo "âŒ ConexÃ£o ao DB ${DB_NAME} falhou"; exit 1; }

            echo "ğŸ” Realizando pg_dump (custom format) do banco '$DB_NAME'..."
            docker exec postgres-staging env PGPASSWORD="$DB_PASS" pg_dump -h localhost -U "$DB_USER" -d "$DB_NAME" -Fc > "$FILE"
            ls -lh "$FILE" || true

            # Guard rail: validar arquivo gerado (nÃ£o-vazio) e tamanho mÃ­nimo
            MIN_SIZE="${{ github.event.inputs.min_dump_size_bytes }}"
            if echo "$MIN_SIZE" | grep -Eq '^[0-9]+$'; then
              SIZE=$(stat -c%s "$FILE" || echo 0)
              if [ "$SIZE" -lt "$MIN_SIZE" ]; then
                echo "âŒ Backup menor que o mÃ­nimo (${SIZE} < ${MIN_SIZE} bytes): $FILE"; exit 2; fi
            else
              if [ ! -s "$FILE" ]; then echo "âŒ Backup vazio ou nÃ£o encontrado: $FILE"; exit 2; fi
            fi

            echo "âœ… Backup criado: $FILE"
            # RetenÃ§Ã£o: manter apenas 30 backups mais recentes
            ls -1t /var/backups/projetogran/staging/projetogran_*.dump | tail -n +31 | xargs -r rm -f

            # Atualiza symlink para facilitar download
            ln -sfn "$FILE" /var/backups/projetogran/staging/latest.dump

            # Imprime caminho para facilitar rastreio nos logs
            echo "DUMP_PATH=$FILE"
          EOF

      - name: ğŸ“¥ Download do dump para o runner
        if: ${{ github.event.inputs.upload_artifact == 'true' }}
        run: |
          set -euo pipefail
          DUMP_PATH=$(ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} "readlink -f /var/backups/projetogran/staging/latest.dump")
          echo "Selecionando dump: $DUMP_PATH"
          FILE_NAME=$(basename "$DUMP_PATH")
          scp -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }}:"$DUMP_PATH" "./$FILE_NAME"
          echo "LOCAL_DUMP=./$FILE_NAME" >> "$GITHUB_ENV"
          echo "LOCAL_DUMP_NAME=$FILE_NAME" >> "$GITHUB_ENV"

      - name: ğŸ“¤ Publicar artifact do dump (com timestamp no nome)
        if: ${{ github.event.inputs.upload_artifact == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: staging-db-backup-${{ env.LOCAL_DUMP_NAME }}
          path: ${{ env.LOCAL_DUMP }}

      - name: ğŸ“‹ Resumo
        run: |
          echo "confirm_env: ${{ github.event.inputs.confirm_env }}"
          echo "min_dump_size_bytes: ${{ github.event.inputs.min_dump_size_bytes }}"
          echo "upload_artifact: ${{ github.event.inputs.upload_artifact }}"
          echo "ğŸ” Verifique os logs para a linha DUMP_PATH com o caminho completo no servidor."